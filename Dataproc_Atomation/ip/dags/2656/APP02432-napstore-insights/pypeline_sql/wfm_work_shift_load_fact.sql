SET QUERY_BAND = '
App_ID=app02432;
DAG_ID=wfm_work_shift_load_2656_napstore_insights;
Task_Name=wfm_work_shift_0_load_1_fct_table;'
FOR SESSION VOLATILE;

ET;

-- SHIFT
-- CREATE TEMPORARY TABLE THAT HAS THE LATEST UNIQUE DATA FOR EACH JOB:
CREATE
VOLATILE MULTISET TABLE WFM_SHIFT_TEMP AS (
    SELECT DISTINCT * FROM {db_env}_NAP_STG.SHIFT_STG
    QUALIFY ROW_NUMBER() OVER (PARTITION BY ID ORDER BY LAST_UPDATED_AT DESC, KAFKA_LAST_UPDATED_AT DESC) = 1
) WITH DATA PRIMARY INDEX(ID) ON COMMIT PRESERVE ROWS;
ET;

-- MERGE AND UPDATE:
MERGE INTO {db_env}_NAP_FCT.SHIFT_FACT TGT
    USING WFM_SHIFT_TEMP SRC
    ON (SRC.ID = TGT.ID)
    WHEN MATCHED THEN
UPDATE
    SET
    CREATED_AT = SRC.CREATED_AT,
    LAST_UPDATED_AT = SRC.LAST_UPDATED_AT,
    EMPLOYEE_ID = SRC.EMPLOYEE_ID,
    STORE_NUMBER = SRC.STORE_NUMBER,
    START_DATE = CAST (SRC.START_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    LOCAL_START_TIME = TIME '00:00:00' + CAST (SRC.LOCAL_START_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    END_DATE = CAST (SRC.END_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    LOCAL_END_TIME = TIME '00:00:00' + CAST (SRC.LOCAL_END_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    REASON = SRC.REASON,
	DELETED = SRC.DELETED,
	DELETED_AT = SRC.DELETED_AT,
    LAST_MODIFIED_USER = SRC.LAST_MODIFIED_USER,
    LAST_MODIFIED_TIMESTAMP = SRC.LAST_MODIFIED_TIMESTAMP,
	DW_SYS_UPDT_TMSTP = CURRENT_TIMESTAMP(6)
WHEN NOT MATCHED THEN
INSERT (
    CREATED_AT,
    LAST_UPDATED_AT,
    ID,
    EMPLOYEE_ID,
    STORE_NUMBER,
    START_DATE,
    LOCAL_START_TIME,
    END_DATE,
    LOCAL_END_TIME,
    REASON,
    DELETED,
    DELETED_AT,
    LAST_MODIFIED_USER,
    LAST_MODIFIED_TIMESTAMP,
	DW_SYS_LOAD_TMSTP,
    DW_SYS_UPDT_TMSTP
)
VALUES (
    SRC.CREATED_AT,
    SRC.LAST_UPDATED_AT,
    SRC.ID,
    SRC.EMPLOYEE_ID,
    SRC.STORE_NUMBER,
    CAST (SRC.START_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    TIME '00:00:00' + CAST (SRC.LOCAL_START_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    CAST (SRC.END_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    TIME '00:00:00' + CAST (SRC.LOCAL_END_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    SRC.REASON,
    SRC.DELETED,
    SRC.DELETED_AT,
    SRC.LAST_MODIFIED_USER,
    SRC.LAST_MODIFIED_TIMESTAMP,
    CURRENT_TIMESTAMP(6),
    CURRENT_TIMESTAMP(6)
    );
ET;

-- SHIFT JOB
-- CREATE TEMPORARY TABLE THAT HAS THE LATEST UNIQUE DATA FOR EACH JOB:
CREATE
VOLATILE MULTISET TABLE WFM_SHIFT_JOB_TEMP AS (
    SELECT DISTINCT * FROM {db_env}_NAP_STG.SHIFT_JOB_STG
    QUALIFY ROW_NUMBER() OVER (PARTITION BY ID ORDER BY LAST_UPDATED_AT DESC, KAFKA_LAST_UPDATED_AT DESC) = 1
) WITH DATA PRIMARY INDEX(ID) ON COMMIT PRESERVE ROWS;
ET;

-- MERGE AND UPDATE:
MERGE INTO {db_env}_NAP_FCT.SHIFT_JOB_FACT TGT
    USING WFM_SHIFT_JOB_TEMP SRC
    ON (SRC.ID = TGT.ID)
    WHEN MATCHED THEN
UPDATE
    SET
    CREATED_AT = SRC.CREATED_AT,
    LAST_UPDATED_AT = SRC.LAST_UPDATED_AT,
    SHIFT_ID = SRC.SHIFT_ID,
    JOB_ID = SRC.JOB_ID,
    START_DATE = CAST (SRC.START_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    LOCAL_START_TIME = TIME '00:00:00' + CAST (SRC.LOCAL_START_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    END_DATE = CAST (SRC.END_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    LOCAL_END_TIME = TIME '00:00:00' + CAST (SRC.LOCAL_END_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    REASON = SRC.REASON,
	DELETED = SRC.DELETED,
	DELETED_AT = SRC.DELETED_AT,
    LAST_MODIFIED_USER = SRC.LAST_MODIFIED_USER,
    LAST_MODIFIED_TIMESTAMP = SRC.LAST_MODIFIED_TIMESTAMP,
    KAFKA_LAST_UPDATED_AT = SRC.KAFKA_LAST_UPDATED_AT,
	DW_SYS_UPDT_TMSTP = CURRENT_TIMESTAMP(6)
WHEN NOT MATCHED THEN
INSERT (
    CREATED_AT,
    LAST_UPDATED_AT,
    ID,
    SHIFT_ID,
    JOB_ID,
    START_DATE,
    LOCAL_START_TIME,
    END_DATE,
    LOCAL_END_TIME,
    REASON,
    DELETED,
    DELETED_AT,
    LAST_MODIFIED_USER,
    LAST_MODIFIED_TIMESTAMP,
    KAFKA_LAST_UPDATED_AT,
	DW_SYS_LOAD_TMSTP,
    DW_SYS_UPDT_TMSTP
)
VALUES (
    SRC.CREATED_AT,
    SRC.LAST_UPDATED_AT,
    SRC.ID,
    SRC.SHIFT_ID,
    SRC.JOB_ID,
    CAST (SRC.START_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    TIME '00:00:00' + CAST (SRC.LOCAL_START_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    CAST (SRC.END_DATE AS DATE FORMAT 'YYYY-MM-DD'),
    TIME '00:00:00' + CAST (SRC.LOCAL_END_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND,
    SRC.REASON,
    SRC.DELETED,
    SRC.DELETED_AT,
    SRC.LAST_MODIFIED_USER,
    SRC.LAST_MODIFIED_TIMESTAMP,
    SRC.KAFKA_LAST_UPDATED_AT,
    CURRENT_TIMESTAMP(6),
    CURRENT_TIMESTAMP(6)
    );

ET;
-- SHIFT JOB DETAIL
-- CREATE TEMPORARY TABLE THAT HAS THE LATEST UNIQUE DATA FOR EACH JOB:
CREATE
VOLATILE MULTISET TABLE WFM_SHIFT_JOB_DETAIL_TEMP AS (
    SELECT DISTINCT
    SHIFT_JOB_ID,
    SHIFT_JOB_DETAIL_TYPE,
    CAST(START_DATE AS DATE FORMAT 'YYYY-MM-DD') as START_DATE,
    TIME '00:00:00' + CAST(LOCAL_START_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND as LOCAL_START_TIME,
    CAST(END_DATE AS DATE FORMAT 'YYYY-MM-DD') as END_DATE,
    TIME '00:00:00' + CAST(LOCAL_END_TIME AS INTEGER) / 1000 * INTERVAL '00:00:01' HOUR TO SECOND as LOCAL_END_TIME,
    LAST_UPDATED_AT,
    KAFKA_LAST_UPDATED_AT
    FROM {db_env}_NAP_STG.SHIFT_JOB_DETAIL_STG
    QUALIFY ROW_NUMBER() OVER (PARTITION BY SHIFT_JOB_ID, SHIFT_JOB_DETAIL_TYPE, START_DATE,
                                            LOCAL_START_TIME, END_DATE, LOCAL_END_TIME
                               ORDER BY LAST_UPDATED_AT DESC, KAFKA_LAST_UPDATED_AT DESC) = 1
) WITH DATA PRIMARY INDEX(SHIFT_JOB_ID, SHIFT_JOB_DETAIL_TYPE, START_DATE, LOCAL_START_TIME, END_DATE, LOCAL_END_TIME) ON COMMIT PRESERVE ROWS;
ET;

-- MERGE AND UPDATE:
MERGE INTO {db_env}_NAP_FCT.SHIFT_JOB_DETAIL_FACT TGT
    USING WFM_SHIFT_JOB_DETAIL_TEMP SRC
    ON (SRC.SHIFT_JOB_ID = TGT.SHIFT_JOB_ID
        AND SRC.SHIFT_JOB_DETAIL_TYPE = TGT.SHIFT_JOB_DETAIL_TYPE
        AND SRC.START_DATE = TGT.START_DATE
        AND SRC.LOCAL_START_TIME = TGT.LOCAL_START_TIME
        AND SRC.END_DATE = TGT.END_DATE
        AND SRC.LOCAL_END_TIME = TGT.LOCAL_END_TIME)
    WHEN MATCHED THEN
        UPDATE
            SET
                LAST_UPDATED_AT = SRC.LAST_UPDATED_AT,
                KAFKA_LAST_UPDATED_AT = SRC.KAFKA_LAST_UPDATED_AT,
                DW_SYS_UPDT_TMSTP = CURRENT_TIMESTAMP(6)
    WHEN NOT MATCHED THEN
        INSERT (
                LAST_UPDATED_AT,
                SHIFT_JOB_ID,
                SHIFT_JOB_DETAIL_TYPE,
                START_DATE,
                LOCAL_START_TIME,
                END_DATE,
                LOCAL_END_TIME,
                KAFKA_LAST_UPDATED_AT,
                DW_SYS_LOAD_TMSTP,
                DW_SYS_UPDT_TMSTP
            )
            VALUES (SRC.LAST_UPDATED_AT,
                    SRC.SHIFT_JOB_ID,
                    SRC.SHIFT_JOB_DETAIL_TYPE,
                    SRC.START_DATE,
                    SRC.LOCAL_START_TIME,
                    SRC.END_DATE,
                    SRC.LOCAL_END_TIME,
                    SRC.KAFKA_LAST_UPDATED_AT,
                    CURRENT_TIMESTAMP(6),
                    CURRENT_TIMESTAMP(6));

ET;

SET QUERY_BAND = NONE FOR SESSION;

ET;
